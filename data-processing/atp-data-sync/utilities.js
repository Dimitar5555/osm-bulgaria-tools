export function preprocess_atp_data(data, configs) {
    data.features = data.features
	.filter(feature => feature.geometry && configs.allowed_countries.indexOf(feature.properties['addr:country']) != -1);
	data.features.forEach(item => {
		item.tags = item.properties;
        delete item.properties;
        item.coordinates = item.geometry.coordinates.toReversed();
        delete item.geometry;
		delete item.type;

		if(data.tags?.opening_hours === 'Mo-Su 00:00-24:00') {
			data.tags.opening_hours = '24/7';
		}
    });
	return data.features;
}

export function distance(a, b, bbox=false) {
	if(bbox){
		var lat_in_bbox = a[0]>=Math.min(bbox[0][0], bbox[1][0]) && a[0]<=Math.max(bbox[0][0], bbox[1][0]);
		var lon_in_bbox = a[1]>=Math.min(bbox[0][1], bbox[1][1]) && a[1]<=Math.max(bbox[0][1], bbox[1][1]);
		if(!lat_in_bbox || !lon_in_bbox){
			return +Infinity;
		}
	}
	const rad_to_deg = Math.PI / 180;
	const earthRadius = 6371000; // Earth's radius in meters
	const dLat = (b[0] - a[0]) * rad_to_deg;
	const dLon = (b[1] - a[1]) * rad_to_deg;
	const a_ =
		Math.sin(dLat / 2) * Math.sin(dLat / 2) +
		Math.cos(a[0] * rad_to_deg) *
		Math.cos(b[0] * rad_to_deg) *
		Math.sin(dLon / 2) * Math.sin(dLon / 2);
	const c_ = 2 * Math.atan2(Math.sqrt(a_), Math.sqrt(1 - a_));
	const distance = +((earthRadius * c_).toFixed(3)); // Distance in meters
	return distance;
}

export function drop_tags(element, is_atp_point=false){
	if(element==undefined){
		return false;
	}
	const tags_to_drop = ['name', 'name:bg', 'name:en', 'nsi_id', '@spider', 'brand:bg', 'brand:en', 'operator', '@source_uri'];
	tags_to_drop.forEach(tag => {
		if(tag=='name' && is_atp_point){
			return;
		}
		if(element.tags && element.tags[tag]){
			delete element.tags[tag];
		}
	});
	return element;
}

export function are_tags_mismatched(osm_tags=[], atp_tags=[], tags_to_compare){
	if(!tags_to_compare){
		return true;
	}
	return tags_to_compare.some(tag => {
		if(tag == 'fuel:*'){
			//const fuels_to_check = ['cng', 'lpg', 'octane_95', 'octane_98', 'octane_100', 'adblue', 'HGV_diesel', 'diesel'];
			var atp_fuels = Object.keys(atp_tags).filter(tag => tag.indexOf('fuel:')==0);
			var osm_fuels = Object.keys(osm_tags).filter(tag => tag.indexOf('fuel:')==0);
			var tags_to_remove = osm_fuels.filter(fuel => atp_fuels.indexOf(fuel)==-1);
			var tags_to_update = atp_fuels.filter(fuel => osm_fuels.indexOf(fuel)==-1 || osm_tags[fuel]!='yes');
			return tags_to_remove.length+tags_to_update.length>0;
		}
		var missing_tag = osm_tags[tag]==undefined && atp_tags[tag];
		var wrong_tag_value = osm_tags[tag] !== atp_tags[tag];
		if(missing_tag || wrong_tag_value){
			return true;
		}
		return false;
	});
}

export function preprocess_osm_data(data) {
    data.elements.forEach((item, index)=>{
		if(item.nodes){
			delete data.elements[index].nodes;
        }
        if(item.tags['brand:wikidata']){
            data.elements[index].wikidata = item.tags['brand:wikidata'];
        }
        else if(item.tags['operator:wikidata']){
			data.elements[index].wikidata = item.tags['operator:wikidata'];
        }
        if(item.center){
			data.elements[index].coordinates = [item.center.lat, item.center.lon];
            delete data.elements[index].center;
        }
        else{
			data.elements[index].coordinates = [item.lat, item.lon];
            delete data.elements[index].lat;
            delete data.elements[index].lon;
        }
		
		if(item.tags.atm === 'yes' && item.tags.amenity === 'bank'){
			let temp = JSON.parse(JSON.stringify(item));
			temp.tags = {amenity: 'atm', note: 'Autogenerated by atm=yes of nearby bank', wikidata: item.wikidata};
			data.elements.push(temp);
		}
    });
}